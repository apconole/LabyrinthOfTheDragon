#!/usr/bin/env node

const fs = require('fs');
const path = require('path')

const namespaces = require('../assets/strings');

/**
 * List of direct substitutions to perform on input strings. Makes it easy to
 * reference special font tiles, etc.
 */
const DirectSubstitutions = {
  '...': '\\xE0',
  ':blind:': '\\x60',
  ':fear:': '\\x62',
  ':paralyze:': '\\x64',
  ':poison:': '\\x66',
  ':confuse:': '\\x68',
  ':agldown:': '\\x6B',
  ':atkdown:': '\\x6D',
  ':defdown:': '\\x6F',
  ':haste:': '\\x76',
  ':regen:': '\\x78',
  ':aglup:': '\\x7B',
  ':atkup:': '\\x7D',
  ':defup:': '\\x7F',
  ':lvl:': '\\x5C\\x5D',
  ':gil:': '\\xA4',
  ':soulcoin:': '\\xA5',
  ':arrow:': '\\A6',
  ':lquo:': '\\xA2',
  ':rquo:': '\\xA3',
  ':a-tier:': '\\x40',
  ':b-tier:': '\\x41',
  ':c-tier:': '\\x42',
  ':s-tier:': '\\x43',
  ':fight:': '\\x96',
  ':magic:': '\\x9A',
  ':tech:': '\\xFB',
  ':item:': '\\xA8',
  ':summon:': '\\xDB',
  ':flee:': '\\xBB',
  '\f': '\\f',
};

const params = {
  '%damage': {
    code: '%d',
    max: 4,
  },
  '%aspect': {
    code: '%s',
    max: 5,
  },
  '%monster': {
    code: '%s',
    max: 9,
  },
  '%c': {
    code: '%c',
    max: 1
  }
};

function encodeString(namespace, key, str, debugOn=false) {
  function debug(...args) {
    if (!debugOn) return;
    args.unshift('debug>')
    console.log.apply(console, args);
  }

  debug('Parsing:', str);

  const maxLineLength = 18;
  const maxTokenLength = 18;
  const maxStringLength = maxLineLength * 3;

  // Break the string down into a series of tokens
  const tokens = str.match(/([ ]+)|([\n\f])|(:[a-z-]+:)|([^\s]+)/g);
  const imr = [];

  function addIMR(k) {
    debug('IMR generated:', k)
    imr.push(k);
  }

  function encode(s) {
    return s.split('').map(c => {
      let hex = c.charCodeAt(0).toString(16);
      if (hex.length > 2) {
        const msg = `Encountered non standard ASCII character with code ${hex}`;
        debug(`${msg}, throwing`);
        throw new Error(`${namespace}.${key} ${msg}`);
      }
      const value = parseInt(hex, 16) + 0x80;
      debug(`Converting hex ${hex} (${c}) to ${value.toString(16)}`);
      hex = value.toString(16);
      return `\\x${hex.toUpperCase()}`;
    }).join('')
  }

  // Generate a list of intermediate representations for the tokens
  tokens.forEach(token => {
    if (token.match(/^%/)) {
      addIMR({ type: 'param', token, encoded: params[token], length: 1 });
      return;
    }

    if (token.match(/:[a-z-]+:/)) {
      addIMR({
        type: 'sub',
        token,
        encoded: DirectSubstitutions[token],
        length: 1
      });
      return;
    }

    if (token.match(/[\n]/)) {
      addIMR({ type: 'control', token, encoded: '\\n', length: 1 });
      return;
    }

    if (token.match(/[\f]/)) {
      addIMR({ type: 'control', token, encoded: '\\f', length: 1 });
      return;
    }

    while(token.length > maxTokenLength) {
      const left = token.substring(0, maxTokenLength - 1) + '-';
      addIMR({
        type: 'text',
        token: left,
        length: left.length,
        encoded: encode(left)
      });
      token = token.substring(maxTokenLength - 1);
    }

    if (token.length > 0) {
      addIMR({
        type: 'text',
        token,
        encoded: encode(token),
        length: token.length,
      });
    }
  });

  let result = '';
  let currentLineLen = 0;
  let totalLen = 0;

  function addLength(n) {
    totalLen += n;
    debug('Total length updated:', totalLen);
    if (totalLen > maxStringLength) {
      debug('Maximum string length exceeded, throwing');
      throw new Error(`${namespace}.${key} exceeds ${maxStringLength} chars.`);
    }
  }

  imr.forEach(rep => {
    debug('Compiling IMR', rep);
    if (currentLineLen + rep.length > maxLineLength) {
      currentLineLen = 0;
      result += '\\n';
      addLength(1);
    }
    addLength(rep.length);
    result += rep.encoded;
  })

  return result;
}

function varName(ns, key) {
  return `str_${ns}_${key}`;
}

function generatedAt() {
  const now = new Date();
  return [
    ' * This file was automatically generated using the tools/strings script',
    ` * Generated at: ${now.toDateString()} @ ${now.toTimeString()}`,
  ].join('\n');
}

class Header {
  constructor () {
    this.variables = [];
  }

  get filename() {
    return 'strings.h'
  }

  get path() {
    return path.resolve('src/', this.filename)
  }

  add(ns, key, value) {
    this.variables.push({ varName: varName(ns, key), value })
  }

  extern(variable) {
    const { varName, value } = variable;
    return [
      '',
      '/**',
      ` * "${value}"`,
      ' */',
      `extern const char ${varName}[];`,
    ].join('\n');
  }

  get headerConst() {
    return '_GAME_STRINGS_H';
  }

  get contents() {
    const now = new Date();
    return [
      '/*',
      ` * ${this.filename}`,
      ` * Extern references for encoded string values across all namespaces.`,
      ` *`,
      generatedAt(),
      ' */',
      `#ifndef ${this.headerConst}`,
      `#define ${this.headerConst}`,
      this.variables.map(v => this.extern(v)).join('\n'),
      '',
      '#endif',
      ''
    ].join('\n');
  }
}

class SourceFile {
  constructor(name, bank) {
    this.name = name;
    this.bank = bank;
    this.entries = [];
  }

  get filename() {
    const bank = this.bank < 10 ? `0${this.bank}` : this.bank;
    return `strings_${this.name}.bank${bank}.c`;
  }

  get path() {
    return path.resolve('data/', this.filename);
  }

  add(key, value) {
    const parsed = encodeString(this.name, key, value);
    this.entries.push({ key, value, parsed });
  }

  var(key) {
    return varName(this.name, key);
  }

  def(entry) {
    const { key, value, parsed } = entry;
    return [
      `const char ${this.var(key)}[] = "${parsed}";`,
    ].join('\n')
  }

  get contents() {
    const now = new Date();
    return [
      '/*',
      ` * ${this.filename}`,
      ` * Encoded string values for the "${this.name}" namespace.`,
      ' *',
      generatedAt(),
      ' */',
      '',
      `#pragma bank ${this.bank}`,
      '',
      this.entries.map(entry => this.def(entry)).join('\n'),
      ''
    ].join('\n')
  }
}

function writeFile(path, contents, type) {
  console.log(`Writing strings ${type} file: ${path}`)
  fs.writeFileSync(path, contents);
}

function main() {
  const header = new Header();
  Object.keys(namespaces).forEach(name => {
    const { strings, bank } = namespaces[name];
    const source = new SourceFile(name, bank)
    Object.keys(strings).forEach(key => {
      header.add(name, key, strings[key]);
      source.add(key, strings[key]);
    })
    writeFile(source.path, source.contents, 'source');
  });
  writeFile(header.path, header.contents, 'header');
}

function testParse(str) {
  const parsed = encodeString('test', 'key', str, true)
  console.log('+--+--+--+--+--+--');
  console.log(str);
  console.log('+--+--+--+--+--+--');
  console.log(parsed.replace('\\n', '\n'));
  console.log('+--+--+--+--+--+--');

  const revert = parsed.split('\\xA0').map(word => {
    const letters = word.split('\\x');
    return letters.filter(k => k.match(/[0-9A-F]{2}/))
  }).flat(1).map(frag => {
    return String.fromCharCode(parseInt(frag, 16) - 0x80)
  }).join('');

  console.log(revert);
}

main();

// testParse(namespaces.ability.strings.mend);
